{"src/examples/toPack/aLotOfTags.tsx":{"isBinary":false,"fileName":"src/examples/toPack/aLotOfTags.tsx","content":"import { AbstractJSXAlone as JSXAlone } from 'jsx-alone-core'\n\nfunction test() {\n\n  const people = [{ name: 'Sebastián', age: 12 }, { name: 'Laura', age: 22 }]\n  const showContactForm = true;\n  return <div className=\"people\">\n\n    <h1>People</h1>\n\n    <p>This example contains lots of combinations of <i>JSX</i> so it's ideal to test\n    <a href=\"https://cancerberosgx.github.io/jsx-alone/jsx-explorer/\">JSX Syntax Highlight</a>\n    </p>\n\n    <hr className=\"hr\" />\n\n    <ul>{people.map((p, i) => <li data-id={`person_${i}`}>\n      <strong {...p} className=\"name\">{p.name}</strong> is\n      <span {...p} className=\"age\">{p.age}</span> years old\n      <div>very\n        <div>nested\n          <p>\n            {[0, 1].map(n =>\n              <div style={{ ...{ ...{ margin: 0 } } }}>test</div>)}\n          </p>\n        </div> \n      </div>\n    </li>)}\n    </ul>\n\n    <hr />\n    <br />\n\n    {showContactForm && <article>\n\n      <h2 {...{ id: 'contactFormTitle' }}>Contact</h2>\n\n      <label>Your name?\n      <input onChange={e => console.log('changed')} />\n      </label>\n\n      <button className=\"button is-primary\"\n        onClick={e => alert(`submitted \\${people.length} persons`)}>Submit</button>\n\n    </article>\n    }\n  </div>\n}"},"src/examples/toPack/dangerouslySetInnerHTML.tsx":{"isBinary":false,"fileName":"src/examples/toPack/dangerouslySetInnerHTML.tsx","content":"import { AbstractJSXAlone as JSXAlone } from 'jsx-alone-core'\n\nfunction sample() {\n  const name = 'Rambo', suffix = 'Mister'\n  return <div className=\"simple2\">Hello\n    <span dangerouslySetInnerHTML={{__html: `\\n<strong>${suffix}</strong>\\n<em className=\"name\">${name}</em>\\n`}}>\n    </span>!\n  </div>\n}\n"},"src/examples/toPack/exampleConditionals.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleConditionals.tsx","content":"import { AbstractJSXAlone as JSXAlone } from 'jsx-alone-core'\n\nfunction conditionals() {\n\n  function makeNode(p = 0.5): Node | undefined {\n    return Math.random() < p ? {\n      getKindName() {\n        return unique('Kind')\n      },\n      getType() {\n        return makeNode()\n      },\n      getText() {\n        return unique('text')\n      },\n      getChildren() {\n        return [makeNode() || makeNode() || makeNode()].filter(e => e)\n      }\n    } as Node : undefined\n  }\n\n  let _unique: number = 0\n  function unique(prefix: string = '_'): string {\n    return prefix + '_' + _unique++\n  }\n\n  function RenderNode(props: { node: Node, mode: string, onShowDetailsOf(p: string, node: Node): void, showDetailsOf: string, path: string, collapsed?: boolean }) {\n\n    const { node, mode, onShowDetailsOf, path, collapsed, showDetailsOf } = props\n    const children = mode === 'forEachChild' ? node.getChildren().reverse() : node.getChildren()\n\n    return <div className=\"content\" data-key={path}>\n\n      <strong>{node.getKindName()}</strong>\n\n      <button className=\"button is-small\" onClick={e => {\n        onShowDetailsOf(path, node)\n      }}>!</button>\n\n      <button className=\"button is-small\" onClick={e => {\n        // this.updateProps({ collapsed: !collapsed })\n      }}>{collapsed ? '+' : '-'}</button>\n\n      {!collapsed && showDetailsOf === path && <div className=\"nodeInfo\">\n        <strong>Text</strong>: <code>\"{node && node.getText()}...\"</code><br />\n        <strong>Type</strong>: <code>{node.getType() && node.getType()!.getText()}</code>\n      </div>}\n\n      {!collapsed && <ul>\n        {children.filter(c => c).map((c, i) => <li>\n          <RenderNode node={c} path={path + i} onShowDetailsOf={onShowDetailsOf} mode={mode} showDetailsOf={showDetailsOf} />\n        </li>)}\n      </ul>}\n\n    </div>\n  }\n\n  const props = {\n    node: makeNode(11)!,\n    mode: 'getChildren',\n    onShowDetailsOf(p: string, node: Node) { },\n    collapsed: false,\n    showDetailsOf: '/00',\n    path: '/00'\n  }\n\n  return <RenderNode {...props} />\n}\n\ninterface Node {\n  getKindName(): string\n  getType(): Node | undefined\n  getText(): string\n  getChildren(): Node[]\n}\n"},"src/examples/toPack/exampleLotsOfComponents.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleLotsOfComponents.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/ import { ElementClass, AbstractJSXAlone as JSXAlone } from 'jsx-alone-core'; declare var PERSON_COUNT: number; declare var CONTACT_COUNT: number; declare var ADDRESS_COUNT: number; function exampleLotsOfComponents() {\n\n  // Auxiliary Style component\n\n  interface StyleProps {\n    classes: { [name: string]: ClassRule },\n    renderConfig?: { indent?: number }\n  }\n  class Style extends ElementClass<StyleProps> {\n    private indent(n: number): string {\n      return this.props.renderConfig && this.props.renderConfig.indent ? new Array(n * 2).fill(0).map(j => ' ').join('') : ''\n    }\n    private fixProperty(s: string): string {\n      let t\n      while (t = /([A-Z])/.exec(s)) {\n        s = s.substring(0, t.index) + '-' + t[1].toLowerCase() + s.substring(t.index + 1, s.length)\n      }\n      return s\n    }\n    render() {\n      const { classes } = this.props\n      const __html = Object.keys(classes).map(c =>\n        `${this.indent(1)}.${c}${(classes[c] && classes[c].selectorPostfix ? classes[c].selectorPostfix : '')} {${\n        Object.keys(classes[c]).filter(p => p !== 'selectorPostfix').map(p => `${\n          this.indent(2)}${this.fixProperty(p)}: ${classes[c][p as any]};`\n        ).join(``)}\n}`).join('\\n')\n      return <style dangerouslySetInnerHTML={{ __html }}></style>\n    }\n    static build<T extends { [k: string]: ClassRule }>(styles: T): { styles: T, classes: { [k in keyof T]: k } } {\n      const classes: any = {}\n      Object.keys(styles).forEach(k => {\n        classes[k] = k\n      })\n      return {\n        styles, classes\n      }\n    }\n  }\n  type ClassRule = Partial<CSSStyleDeclaration> & { selectorPostfix?: string }\n\n  // Auxiliary <If> component\n\n  interface IfProps<T> {\n    c: any, p?: T, children: (...args: NotFalsy<T>[]) =>\n      JSX.Element | (JSX.Element[]) | null\n  }\n  function If<T extends any = any>(props: IfProps<T>) {\n    const f = Array.isArray(props.children) ? props.children[0] : props.children\n    if (isNotFalsy(props.c)) {\n      return f.apply(null, [...(props.p ? [props.p] : []), props.c])\n    }\n    else {\n      return null\n    }\n  }\n  type NotFalsy<C= any> = Exclude<C, Falsy>\n  type Falsy = null | '' | undefined | false\n  function isNotFalsy<T>(a: T): a is NotFalsy<T> { return !!a }\n\n  // THE APP\n\n  // THE APP TyPES\n\n  interface ContactModel {\n    addresses: AddressModel[]\n    phone: string\n  }\n  interface AddressModel {\n    name: string,\n    number: number\n  }\n  interface PersonModel {\n    name: string,\n    age: number\n    contacts: ContactModel[]\n  }\n\n  // THE APP Styles\n\n  const value: ClassRule = {\n    fontWeight: 'bold'\n  }\n  const name: ClassRule = {\n    ...value,\n    border: '2px sold pink'\n  }\n  const number: ClassRule = {\n    ...value,\n    textTransform: 'italic'\n  }\n  const { styles, classes } = Style.build({ value, name, number })\n\n  // The APP components\n\n  const Name = (props: { name: string }) =>\n    <If c={props.name !== 'Seba'}>{() =>\n      <span className={classes.name} data-test=\"name\">{props.name}</span>\n    }</If>\n  const Age = (props: { age: number }) =>\n    <If c={props.age !== 5}>{() =>\n      <span className={classes.number} data-test=\"age\">{props.age}</span>\n    }</If>\n  class Person extends ElementClass<PersonModel> {\n    render() {\n      return <div data-test=\"person\" className=\"person\">\n        <Name name={this.props.name}></Name>\n        <Age age={this.props.age}></Age>\n        {this.props.contacts.map(a =>\n          <Contact addresses={a.addresses} phone={a.phone} />)}\n      </div>\n    }\n  }\n\n  const Address = (props: AddressModel) => <span data-test=\"address\">\n    <span className={classes.name} data-test=\"address-name\">{props.name}</span> number: <span className={classes.number} data-test=\"address-number\">{props.number}</span>\n  </span>\n\n  class Contact extends ElementClass<ContactModel> {\n    render() {\n      return <div data-test=\"contact\">\n        <If c={this.props.addresses.length} p={this.props.addresses}>{addresses => addresses.map(ad =>\n          <Address name={ad.name} number={ad.number} />)\n        }</If>\n      </div>\n    }\n  }\n\n  class App extends ElementClass<AppProps> {\n    render() {\n      return <div>\n        {this.props.people.map(p => <Person {...p} />)}\n      </div>\n    }\n  }\n\n  // MAIN\n\n  function makeModel(personCount = PERSON_COUNT || 10, contactCount = CONTACT_COUNT || 5, addressCount = ADDRESS_COUNT || 3): PersonModel[] {\n\n    return range(personCount).map(i => ({\n      name: name(),\n      age: int(2, 6),\n      contacts: range(contactCount!).map(j => ({\n        addresses: range(addressCount!).map(j => ({\n          name: name(),\n          number: int(10000, 100000)\n        })),\n        phone: int(1000000, 10000000) + ''\n      }))\n    })\n    )\n    function range(i: number) {\n      return new Array(i).fill(0)\n    }\n    function int(a: number, b: number) {\n      return Math.floor(Math.random() * b) + a\n    }\n    function item<T>(a: T[]): T {\n      return a[int(0, a.length)]\n    }\n    function name() {\n      return item(['Seba', 'Laura', 'Andres', 'Zapicán', 'Montezuma'])\n    }\n\n  }\n\n  return <App people={makeModel()}></App>\n}\n\n// THE APP TYPES\n\ninterface Contact {\n  addresses: Address[]\n  phone: string\n}\ninterface Address {\n  name: string,\n  number: number\n}\ninterface Person {\n  name: string,\n  age: number\n  contacts: Contact[]\n}\ninterface AppProps {\n  people: Person[]\n}\n"},"src/examples/toPack/exampleSimple1.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleSimple1.tsx","content":"import { AbstractJSXAlone as JSXAlone } from 'jsx-alone-core'\n\nfunction simple1() {\n  const people = [{ name: 'Sebastián', age: 12 }, { name: 'Laura', age: 22 }]\n  const t0 = Date.now()\n  return <div className=\"people\">\n    <h1>People</h1>\n    <ul>{people.map(p =>\n      <li>\n        <strong className=\"name\">{p.name}</strong> is <span className=\"age\">{p.age}</span> years old\n      </li>)}\n    </ul>\n    <p>Listed {people.length} persons in {(Date.now() - t0) + ''} milliseconds. </p>\n    <button className=\"button is-primary\" onClick={e => alert(`submitted \\${people.length} persons`)}>Submit</button>\n  </div>\n}\n"},"src/examples/toPack/renderInCustomImpls.tsx":{"isBinary":false,"fileName":"src/examples/toPack/renderInCustomImpls.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/import { JSXAloneJsonImpl as JSXAloneJson } from 'jsx-alone-core'; import { JSXAlone as JSXAloneDom } from 'jsx-alone-dom'; import { JSXAlone as JSXAloneString } from 'jsx-alone-string'; const WORD_COUNT = 4, PEOPLE_COUNT = 5\n\nfunction test() {\n  // This test renders JS using different implementations altogether. This is\n  // mostly a hack and you don't do this in the real world, it's just a demo.\n\n  // The way of forcing a custom implementation in this context is creating the\n  // JSXAlone variable and then declare JSX inside an inner function. Returning a\n  // string instead of JSX will result in an element with the string as innerHTML\n\n  let JSXAlone = JSXAloneJson as any\n\n  function render<T= any>(impl: 'json' | 'string' | 'dom', f: () => JSX.Element): T {\n    JSXAlone = impl === 'dom' ? JSXAloneDom : impl === 'string' ? JSXAloneString : JSXAloneJson\n    const jsx = f()\n    const result = JSXAlone.render(jsx)\n    return result as any\n  }\n\n  const arr = (a: number = number(10, 20), b = a) => new Array(Math.trunc(number(a, b) || 1)).fill(0)\n  const string = (length: number = number(10, 20)) => arr(length / 5 + 1).map(i => Math.random().toString(36).substr(2, 5)).reduce((a, b) => a.concat(b))\n  const words = (wordCount = number(10, 20), wordLength = number(5, 10), wordCountB = wordCount, wordLengthB = wordLength) => arr(wordCount, wordCountB).map(i => string(number(wordLength, wordLengthB)))\n  const number = (a = 10, b = a) => Math.floor(Math.random() * b) + (a === b ? 0 : a)\n\n  const C = (props: { label: string }) => <div className=\"content\"><h2>{props.label}</h2>\n    <div>test {string(3)} \"{words(2, 5, 4, 10)}\"</div>\n    <ul>{arr(PEOPLE_COUNT, PEOPLE_COUNT * 2).map(i =>\n      <li>Name: <strong> \"{words(2, 2, 4, 10).join(' ')}\"</strong>. Age: \"{number(100)}\". Answer: <i>\"{words(WORD_COUNT, 2, WORD_COUNT * 2, 14).join('   ')}\"</i></li>)}\n    </ul>\n\n  </div>\n\n  let t0 = Date.now()\n  const s = render('string', () => <C label=\"I once was a string, because JSXAlone string impl was used\" />)\n  const stringTime = Date.now() - t0\n  t0 = Date.now()\n  const json = render('json', () => <C label=\"I wasn't a string nor a DOM element since they used the json impl\" />)\n  const jsonTime = Date.now() - t0\n  t0 = Date.now()\n  const el = render<HTMLElement>('dom', () => <C label={'I was born being a DOM element, this is the proof: ' + JSON.stringify(self.performance.toJSON())} />)\n  const domTime = Date.now() - t0\n\n  // At this point we need to restore the original implementation in order to\n  // declare Elements that the test environment expect (which is the json one)\n  JSXAlone = JSXAloneJson as any\n\n  return <div className=\"content\">\n    <h1>Rendering different implementations</h1>\n    <p>Well, here we have three components that were rendered using the three implementations, in this same page. Timings:  </p>\n    <ul>\n      <li>String: {stringTime}ms.</li>\n      <li>DOM: {domTime}ms.</li>\n      <li>JSON: {jsonTime}ms.</li>\n    </ul>\n    <ul>\n      <li style={{ height: '400px', overflow: 'scroll' }}><h3>String</h3> {s.length + 'bytes'} - we use dangerouslySetInnerHTML to render the string output here.\n        <div>{s}</div>\n      </li>\n      <li style={{ height: '400px', overflow: 'scroll' }}><h3>DOM</h3> {el.outerHTML.length + 'bytes'} -DOM impl currently don't work because examples run in a webworker with has no DOM:\n        <div>{el.outerHTML}</div>\n      </li>\n      <li style={{ height: '400px', overflow: 'scroll' }}><h3>JSON</h3>: we use JSON.stringify() to print the JSON output:\n        <pre>{JSON.stringify(json)}</pre>w\n      </li>\n    </ul>\n  </div>\n}\n"},"src/examples/toPack/renderInCustomImplsSimple.tsx":{"isBinary":false,"fileName":"src/examples/toPack/renderInCustomImplsSimple.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/import { JSXAloneJsonImpl as JSXAlone, JSXAloneJsonImpl as JSXAloneJson, jsonImplOutputElAsHtml, JsonImplOutputEl } from 'jsx-alone-core'; import { JSXAlone as JSXAloneDom } from 'jsx-alone-dom'; import { JSXAlone as JSXAloneString } from 'jsx-alone-string'\n\n// This test renders JS using different implementations altogether. This is\n// mostly a hack and you don't do this in the real world, it's just a demo.\n\n// The way of forcing a custom implementation in this context is creating the\n// JSXAlone variable and then declare JSX inside an inner function.\n\nfunction test() {\n  let JSXAlone = JSXAloneString\n  const s: string = (() => {\n    const el = <div className=\"string\">Hello</div>\n    return JSXAloneString.render(el)\n  })()\n\n  // At this point we need to restore the original implementation in order to\n  // declare Elements that the test environment expect (which is the json one)\n  JSXAlone = JSXAloneJson as any\n  return <pre>{s}</pre>\n}\n"}}